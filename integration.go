package steams

import (
	"iter"
	"slices"
)

// Distinct returns an iterator that yields only unique elements from the
// input iterator. It uses a map to track seen elements, which requires
// O(N) memory.
func Distinct[T comparable](i It[T]) It[T] {
	return func(yield func(T) bool) {
		seen := make(map[T]struct{})
		for v := range i {
			if _, exists := seen[v]; !exists {
				seen[v] = struct{}{}
				if !yield(v) {
					return
				}
			}
		}
	}
}

// Map returns an iterator that applies the transform function to each
// element of the input iterator and yields the results.
func Map[T any, U any](i It[T], transform func(T) U) It[U] {
	return func(yield func(U) bool) {
		for v := range i {
			if !yield(transform(v)) {
				return
			}
		}
	}
}

// FlatMap returns an iterator that applies a transform function to each
// element, where the transform returns another iterator. It then flattens
// the resulting iterators into a single sequence.
func FlatMap[T any, U any](i It[T], transform func(T) It[U]) It[U] {
	return func(yield func(U) bool) {
		for v := range i {
			for innerVal := range transform(v) {
				if !yield(innerVal) {
					return
				}
			}
		}
	}
}

// Fold reduces the iterator to a single value by applying an accumulator
// function, starting with an initial value and processing from left to right.
func Fold[T any, R any](i It[T], initial R, accumulator func(R, T) R) R {
	result := initial
	for v := range i {
		result = accumulator(result, v)
	}
	return result
}

// RFold reduces the iterator to a single value by processing elements
// from right to left. Note: This triggers a full collection of the
// iterator into memory.
func RFold[T any, R any](i It[T], initial R, accumulator func(T, R) R) R {
	var elements []T = i.Collect()
	result := initial
	for i := len(elements) - 1; i >= 0; i-- {
		result = accumulator(elements[i], result)
	}

	return result
}

// Flatten takes an iterator of sequences and returns a single iterator
// yielding all elements from the nested sequences in order.
func Flatten[V any](nested It[iter.Seq[V]]) It[V] {
	return func(yield func(V) bool) {
		for innerSeq := range nested {
			for val := range innerSeq {
				if !yield(val) {
					return
				}
			}
		}
	}
}

// GroupBy organizes elements of the input iterator into groups based on
// a classifier function. It returns a sequence of keys and their
// corresponding iterators.
func GroupBy[K comparable, V any](i It[V], classifier func(V) K) It2[K, It[V]] {
	return func(yield func(K, It[V]) bool) {
		groups := make(map[K][]V)

		for v := range i {
			key := classifier(v)
			groups[key] = append(groups[key], v)
		}

		for k, slice := range groups {
			valIter := It[V](slices.Values(slice))

			if !yield(k, valIter) {
				return
			}
		}
	}
}

// GroupByCounting counts the occurrences of keys generated by the
// classifier function and returns an iterator of key-count pairs.
func GroupByCounting[K comparable, V any](i It[V], classifier func(V) K) It2[K, int] {
	return func(yield func(K, int) bool) {
		counts := make(map[K]int)

		for v := range i {
			key := classifier(v)
			counts[key]++
		}

		for k, count := range counts {
			if !yield(k, count) {
				return
			}
		}
	}
}

// Zip combines two iterators into a single iterator of structs
// containing elements from both. It stops as soon as either input
// iterator is exhausted.
func Zip[T, R any](i1 It[T], i2 It[R]) It[struct {
	First  T
	Second R
}] {
	return func(yield func(struct {
		First  T
		Second R
	}) bool) {
		next1, stop1 := iter.Pull(iter.Seq[T](i1))
		defer stop1()
		next2, stop2 := iter.Pull(iter.Seq[R](i2))
		defer stop2()

		for {
			val1, ok1 := next1()
			val2, ok2 := next2()

			if !ok1 || !ok2 {
				return
			}

			if !yield(struct {
				First  T
				Second R
			}{First: val1, Second: val2}) {
				return
			}
		}
	}
}

// CollectItToIt2 transforms a single-value iterator into a two-value
// iterator (it2) by applying key and value mapping functions to
// each element.
func CollectItToIt2[T, K comparable, V any](i It[T], keyFunc func(T) K, valueFunc func(T) V) It2[K, V] {
	return func(yield func(K, V) bool) {
		for v := range i {
			if !yield(keyFunc(v), valueFunc(v)) {
				return
			}
		}
	}
}

// CollectIt2ToIt transforms a two-value iterator (it2) into a single-value
// iterator by applying a mapper function to each key-value pair.
func CollectIt2ToIt[K comparable, V, R any](i It2[K, V], mapper func(K, V) R) It[R] {
	return func(yield func(R) bool) {
		for k, v := range i {
			if !yield(mapper(k, v)) {
				return
			}
		}
	}
}

// ChainAll concatenates multiple iterators into a single iterator
// that yields all elements from the first, then the second, and so on.
func ChainAll[V any](its ...It[V]) It[V] {
	return func(yield func(V) bool) {
		for _, i := range its {
			for v := range i {
				if !yield(v) {
					return
				}
			}
		}
	}
}
